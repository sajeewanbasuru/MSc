I think that this is the best book that I have read all year. In some sense this is the book that I have been looking for for twenty-five years--the book that will enable me to understand how a computer does what it does. And--given the centrality of computers in our age--it has been a long wait. But now it is over. Charles Petzold (1999), Code: The Hidden Language of Computer Hardware and Software does a much better job than anything else I have ever seen in explaining computers--what they really are, and how they really work.
Have you ever wondered just how your computers really work? I mean, really, really work. Not as in "an electrical signal from memory tells the processor the number to be added," but what the electrical signal is, and how it accomplishes the magic of switching on the circuits that add while switching off the other circuits that would do other things with the number. I have. I have wondered this a lot over the past decades.
Yet somehow over the past several decades my hunger for an explanation has never been properly met. I have listened to people explain how two switches wired in series are an "AND"--only if both switches are closed will the lightbulb light. I have listened to people explain how IP is a packet-based communications protocol and TCP is a connection-based protocol yet the connection-based protocal can ride on top of the packet-based protocol. Somehow these explanations did not satisfy. One seemed like answering "how does a car work?" by telling how in the presence of oxygen carbon-hydrogen bonds are broken and carbon dioxide and water are created. The other seemed like anwering "how does a car work" by telling how if you step on the accelerator the car moves forward.
Charles Petzold is different. He has hit the sweet spot exactly. Enough detail to satisfy anyone. Yet the detail is quickly built up as he ascends to higher and higher levels of explanation. It remains satisfying, but it also hangs together in a big picture.
In fact, my only complaint is that the book isn't long enough. It is mostly a hardware book (unless you want to count Morse Code and the interpretation of flashing light bulbs as "software." By my count there are twenty chapters on hardware, and five on software. In my view only five chapters on software--one on ASCII, one on operating systems, one on floating-point arithmetic, one on high-level languages, and one on GUIs--is about ten too few. (Moreover, at one key place in his explanation (but only one) he waves his hands. He argues that it is possible to use the operation codes stored in memory to control which circuits in the processor are active. But he doesn't show how it is done.)
Charles Petzold's explanatory strategy is to start with the telegraph: with how opening and closing a switch can send an electrical signal down a wire. And he wants to build up, step by step, from that point to end with our modern computers. At the end he hopes that the reader can look back--from the graphical user interface to the high-level language software constructions that generate it, from the high-level language software constructions to the machine-language code that underlies it, from the machine-language code to the electrical signals that load, store, and add bits into the computer's processor and into the computer's memory.
But it doesn't stop there. It goes further down into how to construct an accumulator or a memory bank from logic gates. And then it goes down to how to build logic gates--either out of transistors or telegraph relays. And then deeper down, into how the electrons actually move through a transistor or through a relay and a wire.
And at the end I could look back and say, yes, I understand how this machine works in a way that I didn't understand it before. Before I understood electricity and maybe an AND gate, and I understood high level languages. But the whole vast intermediate realm was fuzzy. Now it is much clearer. I can go from the loop back to the conditional jump back to the way that what is stored in memory is fed into the processor back to the circuits that set the program counter back to the logic gates, and finally back to the doped silicon that makes up the circuit.
So I recommend this book to everyone. It is a true joy to read. And I at least could feel my mind expanding as I read it.